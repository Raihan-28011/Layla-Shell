/* 
 *    Programmed By: Mohammed Isam Mohammed [mohammed_isam1984@yahoo.com]
 *    Copyright 2016, 2017, 2018, 2019 (c)
 * 
 *    file: node.h
 *    This file is part of the Layla Shell project.
 *
 *    Layla Shell is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    Layla Shell is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with Layla Shell.  If not, see <http://www.gnu.org/licenses/>.
 */    

#ifndef NODE_TREE_H
#define NODE_TREE_H

/*
 * types of Abstract Source Tree (AST) nodes, generated by the parser.
 */
enum node_type_e
{
    /* program structs */
    NODE_PROGRAM,           /* the whole translation unit nodetree */
    NODE_FUNCTION,          /* function definition nodetree */
    /* POSIX shell constructs */
    NODE_SUBSHELL,          /* subshell */
    NODE_LIST,              /* list (sequential or asynchronous) */
    NODE_ANDOR,             /* AND-OR list */
    NODE_AND_IF,            /* command on the rightside of a logical AND operator */
    NODE_OR_IF,             /* similar for a logical OR operator */
    NODE_BANG,              /* bang '!' keyword */
    NODE_PIPE,              /* pipeline */
    NODE_TERM,              /* term (similar to an AND-OR list) */
    NODE_WORDLIST,          /* wordlist for use in for and select loops, or case conditionals */
    NODE_VAR,               /* variable name (or simply, a word) */
    NODE_FOR,               /* for loop */
    NODE_SELECT,            /* select loop */
    NODE_CASE_ITEM,         /* case item */
    NODE_CASE,              /* case conditional */
    NODE_IF,                /* if conditional */
    NODE_WHILE,             /* while loop */
    NODE_UNTIL,             /* until loop */
    NODE_IO_FILE,           /* file I/O redirection */
    NODE_IO_HERE,           /* heredoc I/O redirection */
    NODE_IO_REDIRECT,       /* single I/O redirection (file or heredoc) */
    NODE_IO_REDIRECT_LIST,  /* list of I/O redirections */
    NODE_ASSIGNMENT,        /* variable assignment */
    NODE_COMMAND,           /* simple command */
    /* non-POSIX extensions */
    NODE_ARITHMETIC_EXPR,   /* arithmetic expression in the form ((expr)) */
    NODE_TIME,              /* command preceded by the 'time' keyword */
};

/*
 * possible values for the val_type field of the node_s struct (see below).
 */
enum val_type_e
{
    VAL_SINT = 1,       /* signed int */
    VAL_UINT,           /* unsigned int */
    VAL_SLLONG,         /* signed long long */
    VAL_ULLONG,         /* unsigned long long */
    VAL_FLOAT,          /* floating point */
    VAL_LDOUBLE,        /* long double */
    VAL_CHR,            /* char */
    VAL_STR,            /* str (char pointer) */
};

/*
 * a union to hold the value of the val field of the node_s struct (see below).
 */
union symval_u
{
    long               sint;
    unsigned long      uint;
    long long          sllong;
    unsigned long long ullong;
    double             sfloat;
    long double        ldouble;
    char               chr;
    char              *str;
};

/*
 * the node structure, which the parser uses to build the AST.
 */
struct node_s
{
    enum   node_type_e type;    /* type of this node */
    enum   val_type_e val_type; /* type of this node's val field */
    union  symval_u val;        /* value of this node */
    int    children;            /* number of child nodes */
    struct node_s *first_child; /* first child node */
    struct node_s *next_sibling, *prev_sibling; /*
                                                 * if this is a child node, keep
                                                 * pointers to prev/next siblings
                                                 */
    int    lineno;              /* line number where the node's token was encountered */
};

/*
 * functions to manipulate node structs.
 */
struct  node_s *new_node(enum node_type_e type);
void    add_child_node(struct node_s *parent, struct node_s *child);
void    set_node_val_sint(struct node_s *node, int val);
void    set_node_val_uint(struct node_s *node, unsigned int val);
void    set_node_val_sllong(struct node_s *node, long long val);
void    set_node_val_ullong(struct node_s *node, unsigned long long val);
void    set_node_val_sfloat(struct node_s *node, double val);
void    set_node_val_chr(struct node_s *node, char val);
void    set_node_val_str(struct node_s *node, char *val);
char   *get_node_type_str(enum node_type_e type);
void    dump_node_tree(struct node_s *func_body, int level);
void    free_node_tree(struct node_s *node);
// char *nodetree_to_str(struct node_s *root);
char   *cmd_nodetree_to_str(struct node_s *root);
struct  node_s *last_child(struct node_s *parent);

#endif
